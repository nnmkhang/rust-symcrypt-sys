Elliptic curve co-factor handling in SymCrypt
Copyright (c) Microsoft Corporation. Licensed under the MIT license.

Notation
========

    E       The elliptic curve group. This is typically represented as the set of 2D points (with
            coordinates from a finite field) that satisfy a specific curve equation.
            An example equation is y^2 = x^3 + Ax + B for A,B. The set E also
            contains a special "zero" point denoted by O.
    |E|     The total number of points on the elliptic curve group E.
    G       A special point in E which generates a (prime) order subgroup.
    GOrd    The (prime) order of the generator point G. Therefore, GOrd * G = O.
    h       The cofactor of the curve. It is defined as h = |E| / GOrd. Typical
            cofactors are 4 (NUMS curves), and 8 (curve 25519).

Definitions
===========

A "proper public key" (PPK) on the curve E is defined to be an arbitrary nonzero point of the
subgroup generated by the point G.

A "proper secret key" (PSK) is the logarithm of a "proper public key" with
respect to G. Therefore, if Q is the PPK, then the corresponding PSK is the unique
integer s with 0 < s < GOrd such that s*G = Q.

If the cofactor of the curve is equal to 1, then the entire group E is generated by
the point G and all nonzero points in E are "proper public keys".

Otherwise, an arbitrary point on the curve might or might not belong to the subgroup
generated by G. Furthermore, in this case, an arbitrary point P may have order equal
to the cofactor (or smaller), i.e. h*P=O, or an order larger than GOrd.

To securely handle the cases where "non-proper" public keys are imported from possibly malicious
sources, the creators of curve parameters impose several restrictions on the secret keys
and the algorithms used. For example, the scalar multiplication algorithm for NUMS curves
always pre-multiplies a point by the cofactor; in order to zero-out any possible
components of lower order ("low-order clearing"). Curve 25519 imposes this by asserting
that all secret keys have the 3 lowest bits set to 0, which is equivalent to multiplying
by h=8.

This document explains how SymCrypt deals with these different ways of handling this issue.

Secret key formats
==================
The possible secret key format in SymCrypt are shown below. For all formats, s denotes
a "proper secret key" defined as above. I.e. 0 < s < GOrd.

    1. "Canonical":         s
    2. "DivH":              s/h mod GOrd
    3. "DivHTimesH":        h*(s/h mod GOrd)
    4. "TimesH":            h*s                 <-- This format is currently unsupported

Remarks:
    - The above formats apply **only to external formats**: When somebody is
      importing a secret key (from test vectors, for example) or exporting a key.
      The internal format of the secret keys might be one of them or something totally
      different; the internal format is not visible to the caller.
    - Formats 3 and 4 have bigger storage requirements compared to 1 and 2, as
      the key can be up to |E|.
    - When h=1 all formats are identical. This is the case for NIST curves.
    - The NUMS curves use the "DivH" secret key format in the test vectors and the
      multiplication algorithm implicitly multiplies by h.
    - Curve 25519 uses the "DivHTimesH" secret key format in the test vectors.

High bit restrictions
=====================
A high bit restriction is a requirement for some of the high bits of the secret keys
(usually the most significant bits of the curve).
Currently only curve 25519 imposes such a restriction: That the bits 255 and 254 of the
secret key in the "DivHTimesH" format are 0 and 1, respectively.

The high bit restrictions specification takes the following form:
    - Number of bits that are specified
    - Bit position of the lowest bit to be specified (starting from 0 for the LSB)
    - The bit values
The bits that are specified refer to the relevant secret key format.
For Canonical and DivH formats the total number of bits is the # bits of GOrd-1.
For DivHTimesH and TimesH formats the total number of bits is the # bits of |E|-1.

Note: as GOrd must be prime, #bits(Gord) == #bits(Gord-1). The same is true
for |E|=h*GOrd as it can not be a power of 2.

Handling improper public keys  in DH
====================================
The ECDH algorithm can handle improper public keys in three ways.
    - Check that the public key is in <G>. This is expensive (full scalar multiplication).
    - Check that the public key is not of low order, and if that passes ignore the issue.
        (This reveals the private key modulo h to an observer.)
    - Clear the co-factor component of the public key, and check that the result is nonzero.
      Use the cleared public key for further computations.
Note that these approaches are equivalent for PPKs, but differ in the result they produce for
improper public keys.
An improper public key can be written as (Hi + Hp) where Hp is in <G> (a PPK) and Hi is in E/<G>.
Let x be the private key. If the DH exchange reveals x*H = x*(Hi + Hp) = x*Hi + x*Hp then the
attacker can multiply by T:=|<G>| and get T * x * Hi + x * (T * Hp) = x * (T * Hi) which reveals
(x mod h) by inspection as (T*Hi) is known to the attacker (and h is typically small).
The third option simply discards the Hi component of the improper public key and uses only Hp.

Conclusion: The first option is very expensive, the second leaks private key information.
SymCrypt will only implement the third option.

Handling improper public keys in ECDSA
======================================
In ECDSA, the verifier trusts the public key. The verification only checks that the message
was approved by someone who created the public key. For that reason, there is no need to
deal with improper public keys; an attacker that can inject an improper public key can just
as easily inject a proper public key for which he has the private key. (Or the attacker can
compute the public key that corresponds to a (message, signature) pair.)


Proposed framework
==================
Each pre-defined curve will have a **default policy** consisting of:
    - Secret key default external format.
    - High bit restriction; this applies only to the default format.

SymCryptEckeySetRandom
    This generates a key for the curve that obeys any high bit restrictions.
    A flag can be used to ignore the high bit restrictions and generate a private key
    uniformly random in 0 < s < GOrd.

SymCryptEckey(Set/Get)Value
    By default the import/export format is the curve's default format.
    Future work: A parameter can be used to override the default, and specify the private key format.

    To simplify things, SymCrypt reports the #bytes(|E|) as the 'private key size' so that all
    formats will fit in any buffers. Currently there are no curves for which #bytes(GOrd) != #bytes(|E|).

    By default the following verifications are done on key import:
        1. That the (imported) secret key is in the right range for the curve,
            in the right format (TimesH must be a multiple of h) and satisfies the high bit restrictions.
            *** Question: do we verify high bit restrictions if the import is in a non-default format? ***
        2. If both public and private keys are imported: check that they match.
        3. If a public key P is imported: check that it doesn't have low order, i.e. that
           h*P is not equal to O. Note that this is not equivalent to checking that P is a proper public key.
    Two flags can be used to modify this behaviour:
        - The "ignore-validation" flag disables these checks. (for trusted public keys)
        - The "Check-public-key-order" flag adds a check that verifies that the order of the public key is GOrd.
          This detects public keys that are not proper public keys.


SymCryptEcDhSecretAgreement
    This function clears the co-factor of the public key, using only Hp and discarding Hi.
    It verifies that Hp != 0









